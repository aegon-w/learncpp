# C++ 42 Project

> **School Project** | **1337 / 42 Network**

This project is designed to deepen your understanding of **C++** and explore the core concepts of **Object-Oriented Programming (OOP)**. By building scalable and maintainable software, you will develop skills critical for modern software engineering.

## Objectives

- Master the syntax and features of the C++ programming language.
- Learn and apply the principles of **Object-Oriented Programming (OOP)**, including:
  - Encapsulation
  - Inheritance
  - Polymorphism
  - Abstraction
- Develop clean, reusable, and maintainable code.
- Understand how OOP contributes to better software design and development practices.

## Why OOP Matters in Software Development

### 1. **Code Reusability**
OOP enables you to create reusable components by defining classes and objects. Instead of rewriting code, you can build on existing modules, saving time and effort in large-scale projects.

### 2. **Modularity**
OOP organizes code into logical units (classes), making it easier to manage and debug. When a class is well-designed, it acts as a self-contained module that simplifies complexity.

### 3. **Scalability**
With OOP, adding new features or modifying existing functionality becomes easier. Inheritance and polymorphism allow you to extend and adapt existing code without rewriting the entire system.

### 4. **Maintainability**
Encapsulation ensures that the internal state of an object is protected from unintended interference. This reduces the chances of introducing bugs when modifying code.

### 5. **Real-World Modeling**
OOP mimics real-world concepts by representing entities as objects. This makes it intuitive to design software that reflects real-life problems.

---

## Project Overview

This project will challenge you to apply OOP principles to build a robust and functional application using **C++**. You will implement key features that showcase the benefits of OOP in software development.

### Key Requirements

1. **Encapsulation**:
   - Define classes with private, protected, and public members.
   - Use getter and setter methods to control access to data.

2. **Inheritance**:
   - Create a parent class and derive child classes from it.
   - Demonstrate code reuse by extending the functionality of the base class.

3. **Polymorphism**:
   - Implement function overloading and overriding.
   - Use virtual functions and demonstrate runtime polymorphism.

4. **Abstraction**:
   - Define abstract classes and interfaces.
   - Use pure virtual functions to enforce contracts in derived classes.

5. **Memory Management**:
   - Use dynamic memory allocation responsibly.
   - Avoid memory leaks by properly managing destructors.


